07 02 2020
Создаем Серверлесс вариант Переключения Фаз
базируемся на файлах Counters under fire (b) + E8 Phases New Interface (e) AddingAllBtn (a)
 + E8 CheckLoS(b)CnvsOutOfCntr(a)Phases(a) + E8 Phases Old UI(c works)

E:\AllTheNodeProjects\NodePrjct\19.01.2020\Counters under fire (b)


1) 3агрузка 2х экранов 
2) Загрузка Ронделя
3) кнопка Конец Фазы 
4) поворот Ронделя
5) флип хода с картинкой на ронделе

1 фаза :
Есть сломанный и не сломанный Юниты
Есть кнопка End Phase
При выборе Сломанного появляется кнопка Ралли
При нажатии РАлли он Лечится
При выборе Несломанного появляется кнопка Ралли неактивная !
По нажатию End Phase является  кнопка Opp's Rally . Это заглушка в конечном итоге это должно быть событие от сервера при условии конца Фазы
По нажатию Opp's Rally является кнопка Next Phase .
По нажатию Next Phase Рондель прокручивается , выводится название Фазы
По наступлению фазы DFPh кнопка End Phase неактивна, появляется заглуха Opp's End Phase
По окончанию Всех Фаз Кнопка Next Phase становится неактивной, является кнопка End Turn
По нажатию End Turn Картинка на ронделе ФЛипается , становится возможным прокрутить Рондель за Оппонента

для начала сделаем упрощенный вариант , без юнитов 

Наш финальный вариант Main будет получать объект initialSettings от Сервера и запускать Client (который надо бы переименовать в spinalBrain) с данными настройками
Сервер пересылает клиентов по адресу something.html и потому не знает кто будет кем (кто первый игрок , кто второй и т.д.).
Поэтому Main будет из кукисов получать Имя подключившегося игрока , отсылать на сервер это Имя и получать соответствующие настройки 

Здесь же initialSettings будет зашит в Main 

----------------------------------------------------------------------------------------------------------------------------

09 02 2020
Сделано  :
Вывод кнопки 


----------------------------------------------------------------------------------------------------------------------------

10 02 2020
Загрузка и Прокрутка Ронделя на Конец Фазы
Опираемся на E:\AllTheNodeProjects\2\NodePrjct\E8 Phases Old UI( Fire by Group Button(b) target as Hex)

----------------------------------------------------------------------------------------------------------------------------
10 02 2020
Cделано :
Загрузка и отрисовка Ронделя (асинхр. коллбек)
Рондель вращается на 45 град. по нажатию End Phase .
При этом отключаются любые реакции на клик мыши и отключается кнопка End Phase
По завершению вращения устанавливается новый соответствующий Фазе коллбек . Кнопка включается

----------------------------------------------------------------------------------------------------------------------------
Пробуем установить порядок предзагрузки и затем отрисовки
Промисы ?
Асинк ?

Сделал функцию drawRI , которая создает промис загрузки ронделя , ждет его выполнения , затем рисует . Все через async-awayt
Хотелось бы сделать две отдельные ф-ии - ЗАгрузка - отрисовка

--------------------------------------------------------------------------------------------------------------------------

11 02 2020
Сделано три варианта загрузки и отрисовки Ронделя :
Два первых drawRI и drawRondelImage + более абстарактные два метода creatingPromise и draw . 
В дальнейших файлах будут только последние

Реализуем :
По нажатию End Phase является  кнопка Opp's Rally . Это заглушка в конечном итоге это должно быть событие от сервера при условии конца Фазы
По нажатию  Opp's Rally (эмуляция прихода события с сервака) 

End Phase - Не нажимаемая кнопка Waitng For Opponents Rally + кнопка End Opp's Rally ( - можно Раллить оппа )
Waitng For Opponents Rally - кнопка без бекграунда , свойств disabled , enabled

End Phase -  вызывает рзное для разных Фаз . 
Напр. в Фазе FPRPh строит Waitng For Opponents Rally и ждет End Opp's Rally . В Фазе FPPF просто вращает Рондель , как и в большинстве . В FPDFPh (
оборонит огонь второго  игрока) строит Waitng For Opponents Fire и ждет End Opp's DFPh.
В Последней - Флипает стороны

Сейчас колбек новой фазы вешается в конце фтимации Вращения Рондель , что отстойно . 

Построить Разные кнопки в моменты нажатия -  будет видно момент в который строится кнопка и удлинить вращение

--------------------------------------------------------------------------------------------------------------------------------

14 02 2020

Пытаемся понять , почему стартует новый цикл вращения (т.е кнопка не дисейблится . или просто строится новая)


--------------------------------------------------------------------------------------------------------------------------------

17 02 2020

Все нашел .
В момент нажатия кнопки Енд Фаза строилась новая кнопка по buildMenu
Я вынес buildMenu на момент разрешения промиса .

Почистили DrawRI и Promisless Rondel Rotation

Добиваем Фазы и строим Next Turn
DFPh - строим Waitng For Opponents DF - не нажимаемая
End Opp's DFPh

Баг ! При открытии окна вместе с консолью размеры канваса другие - соответсвенно картинка Ронделя смещается !!
При последущем открытии консоли размеры уже установлены и соотв-нно рондель не смещается


--------------------------------------------------------------------------------------------------------------------------------

18 02 2020

Проходят все фазы вплоть до начала второй половины хода
Флипается картинка с изображением сторон .
введен канвас 2

Осталось добить остаток фаз до начала след хода 
Ввести большую кнопку End Turn , которая опять переводит в начало списка Фаз . Только меняем стороны
проверить вынос методов 

-------------------------------------------------------------------------------------------------------------------------------

19 02 2020

Сделал кнопки с названием End Nazi Phase - надо менять свойство name в interfaceScheme
Добил все фазы . Теперь крутится бесконечно , меняя стороны и флипая картинку

Идея! Оставить в this.phaseInterfaceMenuTable только половину . Все равно меняем стороны - соответсвенно == реализовали
Для проверки работоспособности пора вводить пару каунтеров свой - чужой

---------------------------------------------------------------------------------------------------------------------------

20 02 20

Вынесли методы в отдельный файл 
Убрали половину Фаз . Теперь Цикл доходит до firstPlayerCloseCombatPhase , стороны меняются местами . Работает



Идея ! Сохраненка в виде текстового файла -  ЧТо где когда . потом отрисовываем по этому файлу

-------------------------------------------------------------------------------------------------------------------------------

21 02 2020
Сделали отрисовку каунтеры, карту , рондель в этой последовательности . С пом промисов обеспечили загрузкув опр. порядке
Сделаl -  Каунтеры хранят не Имаджи , а Идентификаторы

Делаем - проверка свой чужой по клику в разных фазах

Интерфейс каунтера - Кнопка может быть включенной в данной Фазе , но выключенной по состоянию Каунтера.
Например в Фазу Ралли Интерфейс должен отрисовать кнопку Ралли на любом МС . При этом включенной или выключенной - это зависит от того сломан ли каунтер вообще
Причем возможна обратная ситуация, когда кнопка должна быть выключена в эту Фазу , хоть состояние каунтера разрешает ее включить


-------------------------------------------------------------------------------------------------------------------------------

22 02 2020
Сделал и- проверка свой чужой по клику в Фазе Ралли .
Постройка Интерфейса Ралли для Каунтера

Делаем - Pan и Фаза Перемещения

Как проверить верность Pan ? При клике Каунтер должен перемещаться в верный Гекс (удаленный) . Для этого необходимо использовать координаты связанные непосредственно с Канвасом
Пробуем canvas.relativePan
Работает , хоть и не без лага . Спросил на Стак-е

-------------------------------------------------------------------------------------------------------------------------------

25 02 2020

СОздаем Фазу Мува - Гексосетка , движение , правильное определение координат

Для определения координат привязанных к канвасу (а не к окошку) используем options.absolutePointer: Object { x: 1578.180737217598, y: 473.9970930232558 }

Нарисовали Гекс номер  ноль и все по диагонали
Как  ? 
Получаем координаты , запускаем this.canvasObj.drawPoly(sixCoords, color, callback, hex)
Как получаем координаты ?
Просим модуль Map вычислить нам масив объектов для гекса {0,0,0} : map.getPolyCorners({ q: 0, r: 0, s: 0 })
Как модуль считает ? 
Он запускет свою ф-ю polygon_corners которая получает два объекта : 
1) Объект Layout { orientation, size, origin } - зашита в Маp 
2) Гекс
вычисляет центр , посредством hex_to_pixel
и вычисляет смещение по осям от центра , посредством hex_corner_offset(layout, i) для всех шести точек i


-------------------------------------------------------------------------------------------------------------------------------------

26 02 2020

Все каунтеры получают Гексы на старте . Там и отрисовываются 
Делаем Мувмент
Сделали все граничные условия для Мува аж в трех вариантах


Идея  - реализовать кнопку стоп , появляющаяся в Фазе Мув . При нажатии свич игроков и возхможность отсреляться за  Оппонента
Она становится активной после начала движения и выключается по завершению

Идея - Адванс - это отдельный от Мува тип движения . Отличие- может входить к врагу, нет МР , отсутствует у Танков

Идея - придется сохранять весь путь ММС в файл, чтобы определить есть ли бонус за дорогу

Идея - добавить CSS счетчик шагов с пом body { counter-reset: section; }


-------------------------------------------------------------------------------------------------------------------------------------

27 02 2020

Создали moveProcessing(absolutePointer)
надо создавать группы и их движение

Работает смещение от центра

Каунтер еще не начал движение и кликаем на стоящий в том же гексе - добавляем в Стек . А ведь может мы хотим отказаться от движения и выбрать новый
Только кнопкой Cancel Move Preparation

Проверять на то походил или нет в начале , и если походил - то не выбирается !

Закончил движение ==> undefined + его не выбрать
Проверить - проходит сквозь гекс и кликает на стоящий в нем

Баг - Когда у каунтера еще есть ход и кликешь на свой каунтер , то он не едет , хотя и должен

-------------------------------------------------------------------------------------------------------------------------------------

03 03 2020

Перевел на последний (3-й fabric)
Сделал svg  карту и пехтуру . Впрочем fabric.loadSVGFromURL работает со страшным тормозом
Работает переключение на другого игрока

Делаем : движение стеком
заменим группы на картинки
Создание карты из отдельных гексов
При этом - Поле зерна и Сады делаем дырками в гексах под ними нужные цвета . Правда остается проблема с лесом


-------------------------------------------------------------------------------------------------------------------------------------

04 03 2020

Собрали группу - Клик в точку - Мув процессинг : { Для каждого в Мувинг групп }
или

Собрали группу - Клик в точку - Для каждого в Мувинг групп : {Мув процессинг : }
1) this.selectedCounter  -  undefined по завершению хода хоть одного каунтера . Оттого работает case undefined в firstPlayerMovementPhase
строить Интерфейс для стека ? Не . Больно жирно . 
Добавим в  this.phaseInterfaceMenuTable = { firstPlayerMovementPhase } 'Break Moving Stack'
Изменим проверки в firstPlayerMovementPhase на наличие членов в  this.movingGroupHash.mgArray (this._checkIfSomeoneInMovingGroup)
Поменяем counter != this.selectedCounter на !_checkIfCounterIsInMovingGroup(counter)

Ход в занятую точку

Идея - выделить Создание каунтеров (Фабрика), хранение Трея , Операции с Мувинг и Файринг Групп в отдельный файл

Нужна кнопка Ассалт Мув, Дабл Тайм

 A moving unit or stack of units claims assault move immediately before they begin expending MF. 
 
 Придется вводить текст статус Мувинг и Мувед.
 Мувед - тем кто закончил движение - Кстати можно перекрашивать в серый цвет таких
 Мувинг тем кто нет .
 Например Члены разбитого стека могут закончить движение по очереди
 Реализация :
 1) Группа с Лидером идет на 4 , далее все кроме Л вырубаются , Л идет дальше 
 2) Группа по кнопке Разбить стек разбивается . Всех можно выбирать ! все могут ходить , у всех надпись Мувинг .

 Заканчиваем движение только по кнопке или окончанию Ходов

 Стек :
 selectedCounter = Стек
 Стек  - строим КУИ 
 Двигаем - всем участникам статус Мувинг , если еще не
 Разбиваем - можно выбрать только из тех , что  Мувинг

-------------------------------------------------------------------------------------------------------------------------------------
Добавил 
         // -------------------------------------
        img.set({
            selectable: false,
            evented : false
        })
// -------------------------------------

в createAndDrawGroupOfImgAndBorder . 

и 
// -------------------------------------
                        this.canvasObj.getImageByID(movingCounter.getImageID()).set({
                            selectable: false,
                            evented : false
                        })

// -------------------------------------

в moveProcessing

Не забыть Проверить !

-------------------------------------------------------------------------------------------------------------------------------------

Идея - попробовать http://paperjs.org/tutorials/paths/working-with-path-items/ для интерсекции

Вылечил Баг с группой поставил 
        this.canvas.on({
            'mouse:up': callback
        })

------------------------06 03 2020 -------------------------------------------------------------------------------
Реализовано : 

три каунтера в группе .
У каждого разное МФ . По клику остается первый , потом второй , оставшийся ходит свой остаток
Группа . 

Реализовано :

Проход в занятую точку

Надо доделать :
При выходе с точки , если кто то остался - пересчитываем координаты и смещаем его . Иначе при приходе в эту точку, пришедшие каунтеры смещаются 

Реализуем  МГУИ
Кнопки есть, теперь коллбеки

Как дропнуть одного - а никак

Брейк стак - стиракм группу , но каунтеры со статусом мувед имеют возможность продолжать движение 
Для этого проверяем их статус и если он Мувинг , добавляем в новую группу - нет ?
Допустим есть новая группа , что будет если Брейк произошел в гексе с неходившим каунтером . 
Что если пришел  в такой гекс
Откуда брать остальные недоходившие ?
Введем массив this.allMovingCountersArr и на момент разбиения запишем туда .mgArray (копию)


ситуация :
a) После разбиения стека (case this.getMovigGroup() == undefined ) сразу выбираешь не ходивший (без статуса мувед), не входящий в группу (без желтой рамки) , свой () , каунтер.
b) После разбиения стека выбрал кого-то из входящего в группу , походил им и после этого см. вверх
            if countersFromBrokenMovingStackArray.length != 0 
            countersFromBrokenMovingStackArray.forEach((counte)=>{counter.setStatus('moved'), destroy group}

В чем проблема :
При наличии Мувинг Групп (т.е кого то выбрали для начала хода или ход уже совершается)

1) Если походить каунтером после слома стака , то он не краснеет
2) Если выбрать другой каунтер он не выбирается 
3) Если сломать каунтер, то нвый не выбирается

Сейчас не сработает - отходили остатками , Пытаемся выбрать другой остаток - нет . группа то uncreated
Можно в конце Мув процесс поставить проверку и если это были Олды - то группа пустая но статус Олды

После слома стака начинаем движение сразу и олды не перекрашиваются !

статус сменился на мувинг , дальше не работает

Баг - не плюсует командир +1 бонус для ММС

Идея - условия у которых одинаковый результат объеденить в одно (или или)
Идея - иконки , графически показывающие результат нажатия кнопки

Баг - нет проверки командира под командиром getReadyToMoveUnderSMCcommand

Баг - выбрали К , сломали стак . затем выбрали новый стак  - сломали его . Вылечен

Баг - Ход стаком , Брейк . Выбрали того же - походили . Выбрали следующего из обломков - он мувед , а должен быть Ремнант
Это из за статуса группы . Вылечен

Баг - если кликнуть на свой гекс , то статус группы становится Мувинг . Соответсвенно никого не добавить уже 

-------------------------------- 10 03 20 20 ---------------------------------------------------------------------

Реализовано Движение Группой , Слом стека , новое Движение

Реализация - прерывание Оппонентом , движение с орудиями , кнопка енд мув

В какой момент можно бросать Орудия 
владеть в правилах = possess
передача еквипа другому юниту - в Ралли
подбирать - ив Ралли и в Мувмент (одна попытка за фазу за юнит)

мувингГрупп - добавим weapon

вводим attachWeapon(weapon,counter) - созданному каунтеру аттачится созданное же Орудие

во время firstPlayerMovementPhase в uncreated movingStackStatus группы бьются . надо автоматически приаттачивать свои орудия 
Т.е орудие - отряд линкуются (по ID)

counter.weaponID = weapon.counterID


-------------------------------- 11 03 2020 ---------------

Оргазм братцы ! :

        img.set('stroke', '#f00')
        img.set('strokeWidth',3)
        this.canvasObj.canvas.renderAll()

и не надо групп .

Делаем -  Ренью гекс . Как пересчитываем гекс ? Учитывая , что каунтер + Вепон - группа . Слотовая система ?

Почему не работает нормально this.canvasObj.canvas.renderAll() , если делать сет имаджа ? Картину переносит но без add() ловитее на старом месте

-------------------- Weights ----------------------------------

Нужны для создания групп с орудиями и последующей перегруппировки Каунтеров.
Вес приаттаченного орудия обнуляется и при проходе по всем К в rearrangeCountersPositionInHex(hex) имадж Орудия не получает новых координат , ведь он составляет одно целое с 
ММС , который в свою очередь получает удвоенный Вес в attachCallback, и таким образом начинает занимать сразу два места ( следущий каунтер при расчете координат получит удвоенный кэф)

---------------- Весы аннулированы  ! Вместо них просто сдвигается на 25 % от предыдущего  каунтера --------------------------------------------

При аттаче также добавляем новые элементы интрфейса для каунтера

Убрать совсем вычисление свободных координат ?

Баг - реаррандж в точке которую покидаешь заставляет реарранджиться и группу покидающую
это изза того что при анимации первого кадра координаты ставятся центровые ? -  Вылечен

Реаррендж происходит при покидании и прибытии из/в гекс . А при прибытии все ставятся в центре ?

Идея  - вынести renderAll отовсюду где только можно . Будет видно где лишние
Сделать 
изменить Реаррендж так , чтобы первый каунтер смещался влево и влезали все равномерно

почистить
проверить работает ли назначение = при наличии || и undef 
сделать создание Пулемета как надо
---------------------- 13 03 2020 --------------------------------------------------------------------------------------------------------------------

Сделано 
Реаррендж при покидании гекса
Реаррендж при Аттаче Пулемета
Группы при выборе каунтера заменеы на stroke : 'red'

--------------------- 14 03 2020 -----------------------------------------------------------------



counterFactoryCreate(param) {
    if param.class = 'Arty'
    return (Object.create(protoArty)) .assign(param.options)
}

но в классе видно какие свойства будут назначены , а в фабрике нет

https://habr.com/ru/company/ruvds/blog/351800/

1 don't modify the input object
2 arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры(...arg) позволяют это сделать.
https://learn.javascript.ru/rest-parameters-spread-operator
Spread syntax позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах

    для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля
    для элементов (литералов массива)
    для выражений объектов: в местах, где количество пар "ключ-значение" должно быть равно нулю или больше (для объектных литералов)
Копирование массива

Encapsulate conditionals
Avoid conditionals
Makes adding validation simple when doing a set

Use method chaining
    // NOTE: Returning this for chaining
    return this;

You want to make global changes to derived classes by changing a base class. (Change the caloric expenditure of all animals when they move).

return console.log(

                    if (options.target.counter.getMovingStatus() == 'moved' || ... ||...) {
                    
                    return this.logWhyClickNotWorked(param)
-------------------------------------------------------------------------------------------------------------------------------

let movingStackStatus = this.getMovingStackStatus() - возвращает объект с свойствами , который отличаются в зависимости от того,
какой именно это объект ( при создании группы Фабрикой мы можем создать один из троих состояний ?)
stack.reactionOnclick(options.target)

Реализовать : 
this.getMovingStackStatus() проверяет как на наличие группы вообще , так и на статус анкреейтед . в обоих случаях возвращает 'uncreated'
Группа может быть классом от которого три класса мувинг , файринг , ...
Убрали рамкb выбора 

countersManipulator:

createCounter(param) - factory 
addToCountersTray(counter)
createStack(status) - factory 
addCounterToStack(counter)

attachWeaponToCounter(weapon,counter)
stackSettings


Баг - командир ушел из гекса с каунтерами , пришел , опять ушел - пришел - сдвиг неправильный 
баг - сделали стак с командиром , разбили собрали вновь - ходят с бонусом
Баг - собрали(первй ком-р), прошли, разбили, собрали(первый солдир) - пошли дальше отличается от другого порядка сбора(ком-р снва первый)
Баг - проявляется в зависмиости от того кого первым выбирают



Идея - избавиться от this )) - все ф-ии в формате fight: () => {


     заменить на 
    this.setMovingStatus(counter,status) {
        counter.setMovingStatus('moved')
    }

    this.countersManipulator.getMovingGroup().addCounter(counter)

Идея - танк наследует от weapon - MG - LMG - HMG
                                - Arty - Tank
        или люди тоже от weapon (все могут вести огонь)
=======================================================================================================

Рефакторим - убираем LMG , меняем систему расчета слотов в новом Гексе , выносим button cb, создаем фабрики в каунтерах , чешем MoveProcess , 
выделяем из дескрпшна Идеи

===================================================================================================

убрали LMG
почесали MoveProcess
выделили Идеи
поменяли _calculateFreeCoords

----------------------------------------

Убраkb отовсюду addCounterToHex
почесали MoveProcess
выделили  Bugz
----------------------------------------

меняем в MoveProcess метод forEach на some c прекращением лупа в момент выполнения какого-нибудь условия
из _is_Click_NotInCoverArc_inOwnHex_onEnemy_EnterCostTooHigh
затем можно при условии вылета из лупа не ставить группе статус мувинг (не менять его)
https://ru.stackoverflow.com/questions/611546/%D0%9F%D1%80%D0%B5%D1%80%D0%B2%D0%B0%D1%82%D1%8C-%D1%86%D0%B8%D0%BA%D0%BB-foreach-javascript

===================================================================================================

Ввели фабрику стаков .
Поменяли все вызовы ф-ий на вызовы свойств стаков

------------------------------- 29 03 2020 ----------------------------------------------------------------

использовать Object.setPrototype(newStack.prototype,basicStack.prototype) и protoype : {} для Стэка
использовать отдельные объекты для хранения каждого метода каунтеров . потом повторяющиеся объеденить

Используя деструктуризацию, функция из нашего предыдущего примера будет выглядеть так:

function findUsersByRule ({  rule,  withContactInfo,   includeInactive}) {
//реализация поиска и возврата
}

findUsersByRule({  rule: 'finance',   withContactInfo: true,   includeInactive: true})


Обратите внимание, что наша функция выглядит практически идентично, за исключением того, что мы поставили скобки вокруг наших параметров.
 Вместо получения трех различных параметров наша функция теперь ожидает один объект со свойствами: rule, withContactInfo и includeInactive.

 Проблему с обязательными параметрами также можно решить более элегантным способом.

function requiredParam (param) { 
 const requiredParamError = new Error( `Required parameter, "${param}" is missing.`  )
}

function findUsersByRule ({  rule = requiredParam('rule'),  withContactInfo,   includeInactive} = {}) {...}

---------------------------------------------------------------------------------------------------------------------------------------


var Foo = {
	Foo: function(who) {
		this.me = who;
		return this;
	},
	identify: function() {
		return "I am " + this.me;
	}
};

var Bar = Object.create(Foo);

Bar.Bar = function(who) {
	// "constructors" (aka "initializers") are now in the `[[Prototype]]` chain,
	// so `this.Foo(..)` works easily w/o any problems of relative-polymorphism
	// or .call(this,..) awkwardness of the implicit "mixin" pattern
	this.Foo("Bar:" + who);
	return this;
};


------------------------------------------10 04 2020--------------------------------------------------------------------
Добавил временные файлы counters3 , counters 4
Заменил системы с классами на паттерн Делегирование Поведения часть 1.
Конечные Изменения в файле counters4

Надо менять проверку Статуса Движения в файле move ?
нет добавим :
_check_ForNullTarget_ForOwner_ForMovingStatus(t)

            if (!target.counter.getMovingStatus()) {
            console.log('u try  to select static counter')
            return true
        }
и проверим работу

    getReadyToMoveUnderSMCcommand() {


Далее - подключаем counter4 к client и создаем каунтеры новым способом

------------------------------------------18 04 2020--------------------------------------------------------------------
Поправил баг с командирскимим бонусами

Делаем кнопки остановки

Проверить -  стек -дабл тайм добавить новый каунтер

------------------------------------------24 04 2020--------------------------------------------------------------------

Сделал рабочие кнопки Ассалт Мув , Дабл Тайм и End Movement

------------------------------------------24 04 2020--------------------------------------------------------------------

Делаем дорожный бонус

MUST start on the road, END on the road, and only travel along road hex sides (i.e., literally follow the road).

Создаем стак . Если на дороге - даем бонус . В мув процессе если целевой гекс не дорога - обнуляем . По завершению ходов прибавляем дорожный бонус 

стак мф == 0 .
проверка на бонус 
есть ? добавили
новый клик

таргет Хекс != роад (старт определяется в момент создания tmf +=1)? 
    стартовый гекс дорога ?
        tmf -= 1
        проверяем не кончились ли мf ?
            да - tmf +=1 return

как хранить карту(типы гексов)

------------------------------------------01 05 2020--------------------------------------------------------------------

Сделали все бонусы при передвижении по дороге
Изменение бонусов при сходе с дороги

------------------------------------------02 05 2020--------------------------------------------------------------------

Реализация Defencive Fire
Кнопка DF . 
ПО кнопке - новый Сanvas Listener 

добавили взаимодействие с интерфейсом стека

------------------------------------------04 05 2020--------------------------------------------------------------------
Добавление сквада с орудием в группу
Новая сущность - группа(сквад + орудие) ?
Интерфейс - добавить Сквад в Огневую группу , добавить Орудие

---------------------------------------------------------------------------------------------------------------------

1) аттачим орудие к союзникам
2) на деф фазе если выбираем его  - разбиваем группу , пишем цель

в конце фащы огня всех приаттачиваем обратно

хотя можно реализовать преп файр

---------------------------------------------------------------------------------------------------------------------

При создании группы давать ей свойство = 'Weapon group'
ПРи создании Огневого стека проверять на 'Weapon group'.
Если да , то рисуем кнопки :
'Add Weapon To Fire Group'
'Add Squad To Fire Group'
'Add Both W and S'
По нажатию 

придется делать buildGroupUI , чтобы при повторном выборе группы , где уже выбран Сквад можно было бы добавить Орудие (и обр.)


------------------------------------------17 05 2020--------------------------------------------------------------------

Вынес кнопочные коллбеки в файл
Добавил кнопки добавления Орудия или Отряда в ПрепФайр Фазу
Поправил очистку UI в фазе движения
Тени под кнопками - box-shadow

Реализовал :
убрать кнопки управления группой при клике

addToFiringStack

Реализовать :

клик на группу - выбор орудия - клик на другой Каунт. - убираем UI - добавляем - клик на группу опять - UI c изменениями

firingStack {
    'hex_counter_Hash':{}
}

calculateCommanderBonus


надо выстроить их  в цепочку:
1) проверяем Лос у всех гексов
2) удаляем ЛОсовые гексы из массива
3) для каждого шекса находим ближайшие. Если таковых больше нет - создаем новую группу - файр процессинг
4) если есть - добавляем во временный массив

------------------------------------------26 05 2020--------------------------------------------------------------------

Реализовано:

кнопки добавления в группу
fire processing, fire stack
prepfire start,
box shadow



    getActualFirePower(fp,coweringCoefficient) {

        let array =  Object.keys(this.infantryFireTable)

        var closest = array.reduce((prev, curr) => {
            return (Math.abs(curr - fp) < Math.abs(prev - fp) ? curr : prev);
          });

        let index = array.indexOf(closest)

        return array[index+coweringCoefficient]
        //if ()
    }

в game


calculateWorstHindranceDRM

------------------------------------------29 05 2020--------------------------------------------------------------------

Поломка Пулемета
Сохранение РоФ 
воздействие выстрела на стрелков :
    статус
    группа 
    анимация
атака одного и того же гекса из одного гекса
// let effectOnFirer        ????
// this.useFireOnFirer

пулемет может образовывать стек только  со своим хозяином ?


каунтер  - свойство .groupElements - хранит все элементы , если counter.group
например , если есть пулемет.img
теперь, пулемет со статусом. вместо пулемет.img используем пулемет.group

вводим basicImg = загруженный img
вводим .img = basicImg

стреляет каунтер с пулеметом
уничтожаем группу каунтера
строим заново с измененным статусом ('first fire')
теперь в группе  - статус и пулемет.img
далее стреляет пулемет
строим группу пулемета 
меняем img на группу
иначе при движении пойдет только картинка пулемета без статуса

calculateGroupScheme()

В начале любой манипуляции с имаджем проверяем на наличие группы и вписываем как имадж


_isCounterNearStack

1) если группа  - разбиваем, стираем
    a) создаем новый текст бокс 


------------------------------------------04 06 2020--------------------------------------------------------------------

counter.groupScheme = {
    firingStatus : counter.firingStatusAsTextbox,   ??
    weapon : undefined,
    exhaustion : undefined,
}

this.calculateCoordsForFiringStatusTextbox(counter) {
    let l = counter.img.left
    let t = counter.img.top
    let w = counter.img.width
    return {
            left: l - w / 2 - 12,
            top: t + w / 2,
    }
}

this.drawCounterGroupOnScreen(counter) = {
    let counterImg = counter.img
    let arr = []

    for (let name of counter.groupScheme){
        if (counter.groupScheme[name] == 'firingStatus') {
            let coords =  this.calculateCoordsForFiringStatusTextbox(counter)
            let t = this.canvasObj.createPhaseTextBox
            t.set(coords)
            arr.push(t)
        }
    }

    let g = this.canvasObj.createGroup(...arr)

    this.canvasObj.drawGroup(g)
}

this.drawCounterGroupOnScreen(counter,coords) = {
    counter.img.set
}

------------------------------------------05 06 2020--------------------------------------------------------------------

changeColorOfBorder(counter, color) - вводим counter.initialImg , меняем его


Группа ставит свои коорлдинаты  == 5 и 5 , когда присоеденяется к группе . И возвращает прежние при отделении
                console.log(img)
                i.addWithUpdate(img)

                console.log(img)

                i.removeWithUpdate(img)
                console.log(img)

------------------------------------------05 06 2020--------------------------------------------------------------------

Заменил img на group.
Теперь для редактирования огневого статуса есть counter.text 
                          орудия - counter.group.weapon
Работает

------------------------------------------05 06 2020--------------------------------------------------------------------

Преп фаза
Каждый каунтер получает Статус

------------------------------------------11 06 2020--------------------------------------------------------------------

Реализовано =- влияние ведения огня на Отряд , Пулемет - 

Опять от проблем с группами спас волшебный .set (в flipCounterOnOtherSide) . Не обновлялась картинка пока не сработал set

------------------------------------------18 06 2020--------------------------------------------------------------------

Реализовал:

Работает проверка на пересечение Линии видимости и Линии преграды

------------------------------------------19 06 2020 ----------------------------------------------------------------------

Делаем огонь из нескольких гексов с отсутствующим Лос

------------------------------------------ 30 06 2020 ---------------------------------------------------------------------

Реализовано :
При обнаружении ведущего огонь гекса без ЛоС строится пара кнопок с возможностью выстрелить погруппно или погексово
При огне погруппно строятся новые отдельные  стаки и вызывается fireProcessing для каждого из них

Однако необходим эффект огня также и для остатков

Разделим fireProcessing на 

stack setHex_LoS_Hindrance
if(!this.isEveryFiringHexGotLoS(stack) && stack.getNumberOfHexes()>1)
    buildButton&&Stuff

fireProcessing :
вынесем эффект на стреляющего вверх
эффект на цель запускаем если !stack.noLoSforEveryCounter

------------------------------------------ 01 07 2020 ---------------------------------------------------------------------
Реализовано :

Кнопка separateFire .

Делаем выстрел

как применять Изменения статуса ?

----------------------------------------- 06 07 2020 --------------------------------------------------------------

Находим Лидера
    Получаем статус после проверки
    Устанавливаем Хар-ки после проверки (если изменились)
    Анимируем (если изменились)
        поднимаем
        показываем
        меняем
        показываем

    Устанавливаем Бонус


    ----------------------------------- 07 07 2020 ----------------------------------------------------------------

    Эффект от попадания ver 0.0.1

    рефакторим :

    вводим killingAnimation , desperationAnimation
    разбиваем calcStatus_Change_Animate_UnderFire

 ----------------------------------- 08 07 2020 ----------------------------------------------------------------

 Interdiction

 1 Broken ? Adjacent to Known Enemy ? End of RtPhase ? - Elliminated
 2 Broken ? In Open Ground ? In LoS and normal range of Known Enemy ? Not Low Crawled ? - Elliminated

Start :

1 let brokenArray = 

for each :

1 Adjacent to Known Enemy ? -  add to array
2 In Open Ground ? In LoS and normal range of Known Enemy (that capable to Interdict it i.e fire  at least 1FP)? -  add to array

Known Enemy - все кто In LoS and normal range в стартовом гексе (для каждого Сломленного)
    a) Все Тяжелые пулеметы проверяем на нормал рейндж (16). Если да - в массив
    б) Все легкие (8)
    в) полученный массив проверяем на ЛоС - в новый массив
    г) получаем все гексы на максималном нормальном расстоянии от стартового (6) 
    д) получаем из них массив всех гексов с каунтерами - далее массив гексов с ЛоС 
    е) плюсуем с пулеметным


 1) Собираем всех кто ДОЛЖЕН убегать (см выше).
 2) Даем им tempMF = 6 
 3) Даем статус Desperate
 4) находим ближайшие Здание или Лес , + которое не приближает каунтер к Known Enemy (Даже сломанному !!)

        В радиусе 4 гекса находим все Лес и Здания гексы
        Выделяем те , что не ближе к Known Enemy , чем стартовый гекс
        Подсвечиваем их

 4а) Если таковых нет на расстоянии 4 MF (еще 2 надо на вход) , то можно идти в любое место при условии , что ни один гекс маршрута не приближается к Known Enemy
 6) Двигаемся в Open Ground ? Без Low Crawl ? Known Enemy имеет LoS и нормал рейндж ? Може стрелять хоть 1 ФП ? - Interdiction
    
 2) По нажатию Конец Фазы вновь проверяем на те же условия ( + Not Low Crawled ), если по прежнему да - Уничтожаем

------------------------------------------------------------------------------------------------------------------------

    routPhase(){

        
    }

вместо 
                        if (c.getType() == 'MashineGun' && c.normalRange == 16 && c.owner == 'Ally'){
                            this.secondPlayerHeavyMashineGunsArray.push(c)
                        }

используем Set для создания коллекции Гексов с Пулеметами

collectAllMustRout &

проверяем все гексы вокруг на врагов

this.routPhase() - куда ?

--------------------------------------------------13 07 2020------------------------------------------------------------------

Поменял init , чтобы при загрузке Ломались все , кроме Пулеметов и mustRout получают красный бордер


                    if (counter.getType() != 'MashineGun') {

                        let promise = new Promise((resolve, reject) => {
                            counter.initialImg.setSrc(counter.otherSideSrc, (img) => {
                                resolve(img)
                            })
                        })

                        promArr.push(promise)
                    }

                    Почему ?!

                // let promArr = imgArr.map((image,index)=>{

                //     counter = allCountersArr[index]

                //     // return new Promise((resolve, reject) => {
                //     //     image.setSrc(counter.otherSideSrc, (img) => {
                //     //         resolve(img)
                //     //     })
                //     // })
                //     if (counter.getType() != 'MashineGun') {

                //         return new Promise((resolve, reject) => {
                //             image.setSrc(counter.otherSideSrc, (img) => {
                //                 resolve(img)
                //             })
                //         })
                //     }
                // })

                почему не ловит ошибку и ничего не выдает ?
                reject(new Error("Ошибка!")

------------------------------------------------------------------------------------------------------------


calcPossibleKnownEnemyMG


hex : [hex,hex]

создаем Set гексов сломанных каунтеров
Set гексов с тяжелыми пулеметами плюс Set c легкими = 




проверяем Set гексов сломанных каунтеров на 
    1) Дом, лес + нет Врагов рядом
        true - вписываем в NoKnownEnemyHexesArr
        return
    2) Проходим по  Set c пулеметн. гексами 
        находим дотянувшийся - проверяем на ЛоС
            да - вписываем в hex : [hex,hex] 
    3) Проходим по Массиву со всеми гексами в радиусе Нормал от стартового
        находим тот , что оккупирован Врагом - проверяем на ЛоС
            да - вписываем в hex : [hex,hex]
    4) попал ли гекс в hex : [hex,hex] ?
            нет - вписываем в NoKnownEnemyHexesArr
        return

проходим по каунтерам . 
    свой гекс в hex : [hex,hex] ?
        да - пишем counter.knownEnemy , добавляем в mustRoutCountersArr



------------------------------------------------------------------------------------------------------------

Похоже нам не нужно свойсвто Каунтера .knownEnemy , поскольку есть hex_KnownEnemyHexesArr_Hash ?
Нет вроде надо , иначе после каждог движения нам надо пересчитывать hex_KnownEnemyHexesArr_Hash
или просто делать это

получаем  knownEnemyManCountersArr пока проходим по Брокенам . Писать сразу ? Не обязательно можем вписать из hex_KnownEnemyHexesArr_Hash

Каунтер двигаясь в новый гекс проверяет удаленность от КноунЭнеми , которых берет из hex_KnownEnemyHexesArr_Hash
в новом гексе каунтер просчитывает КноунЭнеми для нового гекса используя calcHex_KnownEnemyHexesArr_Hash() для одного гекса


Спросить на форуме что если он ушел из Лос Одного врага и вошел в Лос Другого ? Остается ли первй КЕ ?




------------------------------ 16 07 2020 --------------------------------------------------------

Продолжаем делать Rout Phase 
Добавил сбор гексов в радиусе N 

calcAllCountersInItsNormalRangeOfHex проверить верность

allHexesKnownEnemyArr - дублирует одинаковые гексы от Пулеметов и просто Врагов 
похоже , что и collectHexesSet работает неверон

--------------------------------- 22 07 2020 -----------------------------------------------------
Rout

умеем вычислять hex_KnownEnemyHexesArr_Hash 

--------------------------------- 22 07 2020 -----------------------------------------------------
Rout

Подсвечиваем Поломанные Каунтеры из hex_KnownEnemyHexesArr_Hash 

firstPlayerRoutPhase

this.mustRoutArr - кто остался  тот умер

Находим ближайшие сейфПлейс , фильтруем те, что приближают к KE
Придется делать два hex_KnownEnemyHexesArr_Hash - hex_KnownEnemyGOODORDERHexesArr_Hash и hex_KnownEnemyHexesArr_Hash 

?? button Choose Location
затем клик на гекс ДОЛЖЕН приближать каунтер к убежищу

- When routing, must rout towards the nearest building or woods that is not closer to a Known Enemy Unit ...
- ...
- Low Crawl is a rout of one hex consistent with the above rules that protects against Interdiction.

https://www.boardgamegeek.com/thread/418698/article/25816086#25816086

In addition, once a routing unit is aware of a Known Enemy Unit, 
it remains aware of it throughout the RtPh, even if its rout path takes it out of the LOS of the Known Enemy Unit.

https://www.boardgamegeek.com/thread/122340/explanation-rout-phase

Как просчитать все возможные маршруты до границ разрешенных гексов ?

Как получить разрешенные гексы ? Т.е. те которые не приближаются к КЕ
1)Вычесть из сферы с центром в Маст Роут гексе и радиусом 4 МF сферы с центрами в КЕ гексах и радиусами равными расстоянию до МР гекса
2)Начать шагать
3)прверять удаление от врагов на каждом ходу и увеличивать сферу с центрами в КЕ гексах  при удалении

проверяем кратчайшее расстояние на легальность , удаляясь от центра

-----------------------------------------------------------------------------------------------------------

определим стартовые гексы с которых начинать рекурсивный поиск путей :
1) пересечение сфер видимости Известных противников
2) вектор в сторону убежища


можно ли НЕ сокращать расстояние при роутинге ?

--------------------------------------------------------------------------------------------------------------

проверим полученную функцию поиска всех маршрутов.
При отсутсвии пути > 4 - показывать ноль. Хотя надо ли - те что дальше возможной дистанции отсекаются (см ниже)

1) nearest SafePlace 
2) closer to Enemy ?
    a) yes to all - next nearest
    b) no to any - place into Array
3) for every in Array check for possible roads without forbidden Hexes 
4) forbidden - only those that towards Enemy

Как проверим.
Цель - на расстоянии 5 гексов
2 врага между Целью и Стартовым гексом
Их сферы видимости - 
    1) пересекаются не оставляя возможного прохода - possible roads == 0 - нет фигня
    2) оставляют проход - только небольшое число

----------------------------------------------------------------------------------------

1) Наступает Раут Фаза
    a) запуск preapring()
        1) выполняются вычисление mustRout и Known Enemy 
        2) mustRout выделяются redBorder
        3) запускаем Слушатель
            a) по клику на один из mustRout :
                1) этот каунтер пишется в temp
                2) из hex_KnownEnemyHexesArr_Hash получаем противников
                3) создаем массив массивов гексов на пересечении ownHex radius == 4 и каждого гекса выше , раскрываем , дедублицируем (массив А)
                4) создаем массив гексов из  ownHex radius не входящих в массив А (может быть равен нулю - каунтер обречен) (массив B)
                    a) равен нулю ? Пишем , что окружен , ретурн
                5) проходим по ближайшим гексам ownHex radius :
                    a) нашли SafePlace ? входит в массив B ? :          //  прошел проверку функцией search7 (с аргументом - массив А (или В ?))?
                         положили в массив (массив С) . если ближайший круг закончен и массив С не ноль :       //- закончили цикл
                            1) проверили все из массива С функцией search7 (с аргументом - массив А (или В ?)) :
                                    a) прошел ? - гекс в массив D , а результат ф-ии search7 в массив E
                                    

                6) обрисовали  все гексы из массива D (даже если он ноль) - это: а) ближайший SafePlace b) не приближает к KnownEnemy с) можно дойти за 4 шага 

                7) меняем Слушатель :
                    a) массив D не ноль ? Выбор целевого гекса :
                        1) рисуем все гексы из массива Е
                        2) можем ходить только по ним
                        3) при выборе гекса массив E уменьшается на те пути которые уже невозможны (перерисовывается)
                    b) массив D ноль :
                        1) клик на любой разрешенный гекс (массив B) 
                        2) пересчитываем массив , учитывая новый стартовый гекс (текущий) и уменьшенный радиус

---------------------------------------------------------------------------------------------------------------------------------------------------

If there are no woods or building hexes within 6 MF (3 MF for a wounded leader) of a routing unit, 
or if none of the woods and buildings within range are legal rout destinations due to the reasons listed in the previous section, 
then the routing unit does not have a rout destination.

A routing unit that does not have a rout destination can rout to any hex it wishes, 
as long as it obeys all of the other routing rules (it cannot move towards a Known Enemy Unit, it cannot move adjacent to a Known Enemy Unit, etc.).
 It does not have to move towards a distant woods/building hex, nor does it have to use all of its available MF.

---------------------------------------------------------------------------------------------------------------------------------------------------


    calcDoomedHexes(hex_KnownEnemyHexesArr_Hash) {

        return Object.keys(hex_KnownEnemyHexesArr_Hash).filter((hex)=>{

            let knownEnemyHexesArr = hex_KnownEnemyHexesArr_Hash[hex]
            let radius = 4
            let arrayOfIntersectingHexes = this.calcIntersectingRanges(hex,radius,knownEnemyHexesArr)
            let legalMoveHexesArr = this.calcDifferenceBetweenRanges(hex,arrayOfIntersectingHexes)

            return legalMoveHexesArr.length>0
        })

    },

    calcIntersectingRanges(hex,radius,hexesArr){
        
        return sumOf
    },

    calcAllIntersectingRanges(intersectingRangesArrays) {
        intersectingRangesArrays.reduce((arr)=>{

        })
    }

----------------------------------------------------------------------------------------------------------------------------------------------------

Проверяем кольцо гексов вокруг . Если есть проход - выполняем нижнее
Если нет - ничего не происходит

1) находим ближайший дом 
2) находим сектор этого дома
3) если выполнено :
    1) дом не приближает к КЕ
    2) сектор дома имеет хоть одну лазейку (гекс примыкающий к стартовому и при этом не приближающийся к КЕ)

    то в этот дом МОЖНО добраться ( если стоимость промежуточных гексов по пути не пшеница и т.п. )

Как не позволить ходить взад вперед ? При шаге считаем расстояние до цели (дом). Уменьшилось ? Ок
Как реализовать возможность пройти дальше по достижению дома ? Просто проверять условия (безопасное место ? не приближается к КЕ ? стоимость норм ?)

Как реализовать отсутствие легальных целей (нет ближайшего дома среди легальных)? Это должен быть раут к любому гексу (выбранному так же как и дом выше)

1) создадим хэш {KE:расстояние}
1) кольцо гексов в массив
2) проверяем первый гекс на расстояние до каждого КЕ из {KE:расстояние} . Оно должно быть не меньше , чем расстояние от юнита до этого КЕ . Где взять расстояние от юнита до этого КЕ ?

3) находим сектор
4) все дома из сектора , которые не прибл к КЕ

нет не так

1) находим интерсекции КЕ и кольца 1гексового . их сумма - все нелегальные гексы
2) если их суммаюдлина == 6 то выходов нет
3) все гексы не входящие в интерсекцию - находим сектор - дома - выделяем - ставим слушатель


firstPlayerRoutPhase

this.canvasObj.setMouseClickListener(this.firstPlayerRoutPhaseSelectedRouting.bind(this),safeplacesArr) - работает , 
но вначале ставит слушатель и только потом реагирует


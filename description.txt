07 02 2020
Создаем Серверлесс вариант Переключения Фаз
базируемся на файлах Counters under fire (b) + E8 Phases New Interface (e) AddingAllBtn (a)
 + E8 CheckLoS(b)CnvsOutOfCntr(a)Phases(a) + E8 Phases Old UI(c works)

E:\AllTheNodeProjects\NodePrjct\19.01.2020\Counters under fire (b)


1) 3агрузка 2х экранов 
2) Загрузка Ронделя
3) кнопка Конец Фазы 
4) поворот Ронделя
5) флип хода с картинкой на ронделе

1 фаза :
Есть сломанный и не сломанный Юниты
Есть кнопка End Phase
При выборе Сломанного появляется кнопка Ралли
При нажатии РАлли он Лечится
При выборе Несломанного появляется кнопка Ралли неактивная !
По нажатию End Phase является  кнопка Opp's Rally . Это заглушка в конечном итоге это должно быть событие от сервера при условии конца Фазы
По нажатию Opp's Rally является кнопка Next Phase .
По нажатию Next Phase Рондель прокручивается , выводится название Фазы
По наступлению фазы DFPh кнопка End Phase неактивна, появляется заглуха Opp's End Phase
По окончанию Всех Фаз Кнопка Next Phase становится неактивной, является кнопка End Turn
По нажатию End Turn Картинка на ронделе ФЛипается , становится возможным прокрутить Рондель за Оппонента

для начала сделаем упрощенный вариант , без юнитов 

Наш финальный вариант Main будет получать объект initialSettings от Сервера и запускать Client (который надо бы переименовать в spinalBrain) с данными настройками
Сервер пересылает клиентов по адресу something.html и потому не знает кто будет кем (кто первый игрок , кто второй и т.д.).
Поэтому Main будет из кукисов получать Имя подключившегося игрока , отсылать на сервер это Имя и получать соответствующие настройки 

Здесь же initialSettings будет зашит в Main 

----------------------------------------------------------------------------------------------------------------------------

09 02 2020
Сделано  :
Вывод кнопки 


----------------------------------------------------------------------------------------------------------------------------

10 02 2020
Загрузка и Прокрутка Ронделя на Конец Фазы
Опираемся на E:\AllTheNodeProjects\2\NodePrjct\E8 Phases Old UI( Fire by Group Button(b) target as Hex)

----------------------------------------------------------------------------------------------------------------------------
10 02 2020
Cделано :
Загрузка и отрисовка Ронделя (асинхр. коллбек)
Рондель вращается на 45 град. по нажатию End Phase .
При этом отключаются любые реакции на клик мыши и отключается кнопка End Phase
По завершению вращения устанавливается новый соответствующий Фазе коллбек . Кнопка включается

----------------------------------------------------------------------------------------------------------------------------
Пробуем установить порядок предзагрузки и затем отрисовки
Промисы ?
Асинк ?

Сделал функцию drawRI , которая создает промис загрузки ронделя , ждет его выполнения , затем рисует . Все через async-awayt
Хотелось бы сделать две отдельные ф-ии - ЗАгрузка - отрисовка

--------------------------------------------------------------------------------------------------------------------------

11 02 2020
Сделано три варианта загрузки и отрисовки Ронделя :
Два первых drawRI и drawRondelImage + более абстарактные два метода creatingPromise и draw . 
В дальнейших файлах будут только последние

Реализуем :
По нажатию End Phase является  кнопка Opp's Rally . Это заглушка в конечном итоге это должно быть событие от сервера при условии конца Фазы
По нажатию  Opp's Rally (эмуляция прихода события с сервака) 

End Phase - Не нажимаемая кнопка Waitng For Opponents Rally + кнопка End Opp's Rally ( - можно Раллить оппа )
Waitng For Opponents Rally - кнопка без бекграунда , свойств disabled , enabled

End Phase -  вызывает рзное для разных Фаз . 
Напр. в Фазе FPRPh строит Waitng For Opponents Rally и ждет End Opp's Rally . В Фазе FPPF просто вращает Рондель , как и в большинстве . В FPDFPh (
оборонит огонь второго  игрока) строит Waitng For Opponents Fire и ждет End Opp's DFPh.
В Последней - Флипает стороны

Сейчас колбек новой фазы вешается в конце фтимации Вращения Рондель , что отстойно . 

Построить Разные кнопки в моменты нажатия -  будет видно момент в который строится кнопка и удлинить вращение

--------------------------------------------------------------------------------------------------------------------------------

14 02 2020

Пытаемся понять , почему стартует новый цикл вращения (т.е кнопка не дисейблится . или просто строится новая)


--------------------------------------------------------------------------------------------------------------------------------

17 02 2020

Все нашел .
В момент нажатия кнопки Енд Фаза строилась новая кнопка по buildMenu
Я вынес buildMenu на момент разрешения промиса .

Почистили DrawRI и Promisless Rondel Rotation

Добиваем Фазы и строим Next Turn
DFPh - строим Waitng For Opponents DF - не нажимаемая
End Opp's DFPh

Баг ! При открытии окна вместе с консолью размеры канваса другие - соответсвенно картинка Ронделя смещается !!
При последущем открытии консоли размеры уже установлены и соотв-нно рондель не смещается


--------------------------------------------------------------------------------------------------------------------------------

18 02 2020

Проходят все фазы вплоть до начала второй половины хода
Флипается картинка с изображением сторон .
введен канвас 2

Осталось добить остаток фаз до начала след хода 
Ввести большую кнопку End Turn , которая опять переводит в начало списка Фаз . Только меняем стороны
проверить вынос методов 

-------------------------------------------------------------------------------------------------------------------------------

19 02 2020

Сделал кнопки с названием End Nazi Phase - надо менять свойство name в interfaceScheme
Добил все фазы . Теперь крутится бесконечно , меняя стороны и флипая картинку

Идея! Оставить в this.phaseInterfaceMenuTable только половину . Все равно меняем стороны - соответсвенно == реализовали
Для проверки работоспособности пора вводить пару каунтеров свой - чужой

---------------------------------------------------------------------------------------------------------------------------

20 02 20

Вынесли методы в отдельный файл 
Убрали половину Фаз . Теперь Цикл доходит до firstPlayerCloseCombatPhase , стороны меняются местами . Работает



Идея ! Сохраненка в виде текстового файла -  ЧТо где когда . потом отрисовываем по этому файлу

-------------------------------------------------------------------------------------------------------------------------------

21 02 2020
Сделали отрисовку каунтеры, карту , рондель в этой последовательности . С пом промисов обеспечили загрузкув опр. порядке
Сделаl -  Каунтеры хранят не Имаджи , а Идентификаторы

Делаем - проверка свой чужой по клику в разных фазах

Интерфейс каунтера - Кнопка может быть включенной в данной Фазе , но выключенной по состоянию Каунтера.
Например в Фазу Ралли Интерфейс должен отрисовать кнопку Ралли на любом МС . При этом включенной или выключенной - это зависит от того сломан ли каунтер вообще
Причем возможна обратная ситуация, когда кнопка должна быть выключена в эту Фазу , хоть состояние каунтера разрешает ее включить


-------------------------------------------------------------------------------------------------------------------------------

22 02 2020
Сделал и- проверка свой чужой по клику в Фазе Ралли .
Постройка Интерфейса Ралли для Каунтера

Делаем - Pan и Фаза Перемещения

Как проверить верность Pan ? При клике Каунтер должен перемещаться в верный Гекс (удаленный) . Для этого необходимо использовать координаты связанные непосредственно с Канвасом
Пробуем canvas.relativePan
Работает , хоть и не без лага . Спросил на Стак-е

-------------------------------------------------------------------------------------------------------------------------------

25 02 2020

СОздаем Фазу Мува - Гексосетка , движение , правильное определение координат

Для определения координат привязанных к канвасу (а не к окошку) используем options.absolutePointer: Object { x: 1578.180737217598, y: 473.9970930232558 }

Нарисовали Гекс номер  ноль и все по диагонали
Как  ? 
Получаем координаты , запускаем this.canvasObj.drawPoly(sixCoords, color, callback, hex)
Как получаем координаты ?
Просим модуль Map вычислить нам масив объектов для гекса {0,0,0} : map.getPolyCorners({ q: 0, r: 0, s: 0 })
Как модуль считает ? 
Он запускет свою ф-ю polygon_corners которая получает два объекта : 
1) Объект Layout { orientation, size, origin } - зашита в Маp 
2) Гекс
вычисляет центр , посредством hex_to_pixel
и вычисляет смещение по осям от центра , посредством hex_corner_offset(layout, i) для всех шести точек i


-------------------------------------------------------------------------------------------------------------------------------------

26 02 2020

Все каунтеры получают Гексы на старте . Там и отрисовываются 
Делаем Мувмент
Сделали все граничные условия для Мува аж в трех вариантах


Идея  - реализовать кнопку стоп , появляющаяся в Фазе Мув . При нажатии свич игроков и возхможность отсреляться за  Оппонента
Она становится активной после начала движения и выключается по завершению

Идея - Адванс - это отдельный от Мува тип движения . Отличие- может входить к врагу, нет МР , отсутствует у Танков

Идея - придется сохранять весь путь ММС в файл, чтобы определить есть ли бонус за дорогу

Идея - добавить CSS счетчик шагов с пом body { counter-reset: section; }


-------------------------------------------------------------------------------------------------------------------------------------

27 02 2020

Создали moveProcessing(absolutePointer)
надо создавать группы и их движение

Работает смещение от центра

Каунтер еще не начал движение и кликаем на стоящий в том же гексе - добавляем в Стек . А ведь может мы хотим отказаться от движения и выбрать новый
Только кнопкой Cancel Move Preparation

Проверять на то походил или нет в начале , и если походил - то не выбирается !

Закончил движение ==> undefined + его не выбрать
Проверить - проходит сквозь гекс и кликает на стоящий в нем

Баг - Когда у каунтера еще есть ход и кликешь на свой каунтер , то он не едет , хотя и должен

-------------------------------------------------------------------------------------------------------------------------------------

03 03 2020

Перевел на последний (3-й fabric)
Сделал svg  карту и пехтуру . Впрочем fabric.loadSVGFromURL работает со страшным тормозом
Работает переключение на другого игрока

Делаем : движение стеком
заменим группы на картинки
Создание карты из отдельных гексов
При этом - Поле зерна и Сады делаем дырками в гексах под ними нужные цвета . Правда остается проблема с лесом


-------------------------------------------------------------------------------------------------------------------------------------

04 03 2020

Собрали группу - Клик в точку - Мув процессинг : { Для каждого в Мувинг групп }
или

Собрали группу - Клик в точку - Для каждого в Мувинг групп : {Мув процессинг : }
1) this.selectedCounter  -  undefined по завершению хода хоть одного каунтера . Оттого работает case undefined в firstPlayerMovementPhase
строить Интерфейс для стека ? Не . Больно жирно . 
Добавим в  this.phaseInterfaceMenuTable = { firstPlayerMovementPhase } 'Break Moving Stack'
Изменим проверки в firstPlayerMovementPhase на наличие членов в  this.movingGroupHash.mgArray (this._checkIfSomeoneInMovingGroup)
Поменяем counter != this.selectedCounter на !_checkIfCounterIsInMovingGroup(counter)

Ход в занятую точку

Идея - выделить Создание каунтеров (Фабрика), хранение Трея , Операции с Мувинг и Файринг Групп в отдельный файл

Нужна кнопка Ассалт Мув, Дабл Тайм

 A moving unit or stack of units claims assault move immediately before they begin expending MF. 
 
 Придется вводить текст статус Мувинг и Мувед.
 Мувед - тем кто закончил движение - Кстати можно перекрашивать в серый цвет таких
 Мувинг тем кто нет .
 Например Члены разбитого стека могут закончить движение по очереди
 Реализация :
 1) Группа с Лидером идет на 4 , далее все кроме Л вырубаются , Л идет дальше 
 2) Группа по кнопке Разбить стек разбивается . Всех можно выбирать ! все могут ходить , у всех надпись Мувинг .

 Заканчиваем движение только по кнопке или окончанию Ходов

 Стек :
 selectedCounter = Стек
 Стек  - строим КУИ 
 Двигаем - всем участникам статус Мувинг , если еще не
 Разбиваем - можно выбрать только из тех , что  Мувинг

-------------------------------------------------------------------------------------------------------------------------------------
Добавил 
         // -------------------------------------
        img.set({
            selectable: false,
            evented : false
        })
// -------------------------------------

в createAndDrawGroupOfImgAndBorder . 

и 
// -------------------------------------
                        this.canvasObj.getImageByID(movingCounter.getImageID()).set({
                            selectable: false,
                            evented : false
                        })

// -------------------------------------

в moveProcessing

Не забыть Проверить !

-------------------------------------------------------------------------------------------------------------------------------------

Идея - попробовать http://paperjs.org/tutorials/paths/working-with-path-items/ для интерсекции

Вылечил Баг с группой поставил 
        this.canvas.on({
            'mouse:up': callback
        })

------------------------06 03 2020 -------------------------------------------------------------------------------
Реализовано : 

три каунтера в группе .
У каждого разное МФ . По клику остается первый , потом второй , оставшийся ходит свой остаток
Группа . 

Реализовано :

Проход в занятую точку

Надо доделать :
При выходе с точки , если кто то остался - пересчитываем координаты и смещаем его . Иначе при приходе в эту точку, пришедшие каунтеры смещаются 

Реализуем  МГУИ
Кнопки есть, теперь коллбеки

Как дропнуть одного - а никак

Брейк стак - стиракм группу , но каунтеры со статусом мувед имеют возможность продолжать движение 
Для этого проверяем их статус и если он Мувинг , добавляем в новую группу - нет ?
Допустим есть новая группа , что будет если Брейк произошел в гексе с неходившим каунтером . 
Что если пришел  в такой гекс
Откуда брать остальные недоходившие ?
Введем массив this.allMovingCountersArr и на момент разбиения запишем туда .mgArray (копию)


ситуация :
a) После разбиения стека (case this.getMovigGroup() == undefined ) сразу выбираешь не ходивший (без статуса мувед), не входящий в группу (без желтой рамки) , свой () , каунтер.
b) После разбиения стека выбрал кого-то из входящего в группу , походил им и после этого см. вверх
            if countersFromBrokenMovingStackArray.length != 0 
            countersFromBrokenMovingStackArray.forEach((counte)=>{counter.setStatus('moved'), destroy group}

В чем проблема :
При наличии Мувинг Групп (т.е кого то выбрали для начала хода или ход уже совершается)

1) Если походить каунтером после слома стака , то он не краснеет
2) Если выбрать другой каунтер он не выбирается 
3) Если сломать каунтер, то нвый не выбирается

Сейчас не сработает - отходили остатками , Пытаемся выбрать другой остаток - нет . группа то uncreated
Можно в конце Мув процесс поставить проверку и если это были Олды - то группа пустая но статус Олды

После слома стака начинаем движение сразу и олды не перекрашиваются !

статус сменился на мувинг , дальше не работает

Баг - не плюсует командир +1 бонус для ММС

Идея - условия у которых одинаковый результат объеденить в одно (или или)
Идея - иконки , графически показывающие результат нажатия кнопки

Баг - нет проверки командира под командиром getReadyToMoveUnderSMCcommand

Баг - выбрали К , сломали стак . затем выбрали новый стак  - сломали его . Вылечен

Баг - Ход стаком , Брейк . Выбрали того же - походили . Выбрали следующего из обломков - он мувед , а должен быть Ремнант
Это из за статуса группы . Вылечен

Баг - если кликнуть на свой гекс , то статус группы становится Мувинг . Соответсвенно никого не добавить уже 

-------------------------------- 10 03 20 20 ---------------------------------------------------------------------

Реализовано Движение Группой , Слом стека , новое Движение

Реализация - прерывание Оппонентом , движение с орудиями , кнопка енд мув

В какой момент можно бросать Орудия 
владеть в правилах = possess
передача еквипа другому юниту - в Ралли
подбирать - ив Ралли и в Мувмент (одна попытка за фазу за юнит)

мувингГрупп - добавим weapon

вводим attachWeapon(weapon,counter) - созданному каунтеру аттачится созданное же Орудие

во время firstPlayerMovementPhase в uncreated movingStackStatus группы бьются . надо автоматически приаттачивать свои орудия 
Т.е орудие - отряд линкуются (по ID)

counter.weaponID = weapon.counterID


-------------------------------- 11 03 2020 ---------------

Оргазм братцы ! :

        img.set('stroke', '#f00')
        img.set('strokeWidth',3)
        this.canvasObj.canvas.renderAll()

и не надо групп .

Делаем -  Ренью гекс . Как пересчитываем гекс ? Учитывая , что каунтер + Вепон - группа . Слотовая система ?

Почему не работает нормально this.canvasObj.canvas.renderAll() , если делать сет имаджа ? Картину переносит но без add() ловитее на старом месте

-------------------- Weights ----------------------------------

Нужны для создания групп с орудиями и последующей перегруппировки Каунтеров.
Вес приаттаченного орудия обнуляется и при проходе по всем К в rearrangeCountersPositionInHex(hex) имадж Орудия не получает новых координат , ведь он составляет одно целое с 
ММС , который в свою очередь получает удвоенный Вес в attachCallback, и таким образом начинает занимать сразу два места ( следущий каунтер при расчете координат получит удвоенный кэф)

---------------- Весы аннулированы  ! Вместо них просто сдвигается на 25 % от предыдущего  каунтера --------------------------------------------

При аттаче также добавляем новые элементы интрфейса для каунтера

Убрать совсем вычисление свободных координат ?

Баг - реаррандж в точке которую покидаешь заставляет реарранджиться и группу покидающую
это изза того что при анимации первого кадра координаты ставятся центровые ? -  Вылечен

Реаррендж происходит при покидании и прибытии из/в гекс . А при прибытии все ставятся в центре ?

Идея  - вынести renderAll отовсюду где только можно . Будет видно где лишние
Сделать 
изменить Реаррендж так , чтобы первый каунтер смещался влево и влезали все равномерно

почистить
проверить работает ли назначение = при наличии || и undef 
сделать создание Пулемета как надо
---------------------- 13 03 2020 --------------------------------------------------------------------------------------------------------------------

Сделано 
Реаррендж при покидании гекса
Реаррендж при Аттаче Пулемета
Группы при выборе каунтера заменеы на stroke : 'red'

--------------------- 14 03 2020 -----------------------------------------------------------------



counterFactoryCreate(param) {
    if param.class = 'Arty'
    return (Object.create(protoArty)) .assign(param.options)
}

но в классе видно какие свойства будут назначены , а в фабрике нет

https://habr.com/ru/company/ruvds/blog/351800/

1 don't modify the input object
2 arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры(...arg) позволяют это сделать.
https://learn.javascript.ru/rest-parameters-spread-operator
Spread syntax позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах

    для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля
    для элементов (литералов массива)
    для выражений объектов: в местах, где количество пар "ключ-значение" должно быть равно нулю или больше (для объектных литералов)
Копирование массива

Encapsulate conditionals
Avoid conditionals
Makes adding validation simple when doing a set

Use method chaining
    // NOTE: Returning this for chaining
    return this;

You want to make global changes to derived classes by changing a base class. (Change the caloric expenditure of all animals when they move).

return console.log(

                    if (options.target.counter.getMovingStatus() == 'moved' || ... ||...) {
                    
                    return this.logWhyClickNotWorked(param)
-------------------------------------------------------------------------------------------------------------------------------

let movingStackStatus = this.getMovingStackStatus() - возвращает объект с свойствами , который отличаются в зависимости от того,
какой именно это объект ( при создании группы Фабрикой мы можем создать один из троих состояний ?)
stack.reactionOnclick(options.target)

Реализовать : 
this.getMovingStackStatus() проверяет как на наличие группы вообще , так и на статус анкреейтед . в обоих случаях возвращает 'uncreated'
Группа может быть классом от которого три класса мувинг , файринг , ...
Убрали рамкb выбора 

countersManipulator:

createCounter(param) - factory 
addToCountersTray(counter)
createStack(status) - factory 
addCounterToStack(counter)

attachWeaponToCounter(weapon,counter)
stackSettings


Баг - командир ушел из гекса с каунтерами , пришел , опять ушел - пришел - сдвиг неправильный 
баг - сделали стак с командиром , разбили собрали вновь - ходят с бонусом
Баг - собрали(первй ком-р), прошли, разбили, собрали(первый солдир) - пошли дальше отличается от другого порядка сбора(ком-р снва первый)
Баг - проявляется в зависмиости от того кого первым выбирают



Идея - избавиться от this )) - все ф-ии в формате fight: () => {


     заменить на 
    this.setMovingStatus(counter,status) {
        counter.setMovingStatus('moved')
    }

    this.countersManipulator.getMovingGroup().addCounter(counter)

Идея - танк наследует от weapon - MG - LMG - HMG
                                - Arty - Tank
        или люди тоже от weapon (все могут вести огонь)
=======================================================================================================

Рефакторим - убираем LMG , меняем систему расчета слотов в новом Гексе , выносим button cb, создаем фабрики в каунтерах , чешем MoveProcess , 
выделяем из дескрпшна Идеи

===================================================================================================

убрали LMG
почесали MoveProcess
выделили Идеи
поменяли _calculateFreeCoords

----------------------------------------

Убраkb отовсюду addCounterToHex
почесали MoveProcess
выделили  Bugz
----------------------------------------

меняем в MoveProcess метод forEach на some c прекращением лупа в момент выполнения какого-нибудь условия
из _is_Click_NotInCoverArc_inOwnHex_onEnemy_EnterCostTooHigh
затем можно при условии вылета из лупа не ставить группе статус мувинг (не менять его)
https://ru.stackoverflow.com/questions/611546/%D0%9F%D1%80%D0%B5%D1%80%D0%B2%D0%B0%D1%82%D1%8C-%D1%86%D0%B8%D0%BA%D0%BB-foreach-javascript

===================================================================================================

Ввели фабрику стаков .
Поменяли все вызовы ф-ий на вызовы свойств стаков

------------------------------- 29 03 2020 ----------------------------------------------------------------

использовать Object.setPrototype(newStack.prototype,basicStack.prototype) и protoype : {} для Стэка
использовать отдельные объекты для хранения каждого метода каунтеров . потом повторяющиеся объеденить

Используя деструктуризацию, функция из нашего предыдущего примера будет выглядеть так:

function findUsersByRule ({  rule,  withContactInfo,   includeInactive}) {
//реализация поиска и возврата
}

findUsersByRule({  rule: 'finance',   withContactInfo: true,   includeInactive: true})


Обратите внимание, что наша функция выглядит практически идентично, за исключением того, что мы поставили скобки вокруг наших параметров.
 Вместо получения трех различных параметров наша функция теперь ожидает один объект со свойствами: rule, withContactInfo и includeInactive.

 Проблему с обязательными параметрами также можно решить более элегантным способом.

function requiredParam (param) { 
 const requiredParamError = new Error( `Required parameter, "${param}" is missing.`  )
}

function findUsersByRule ({  rule = requiredParam('rule'),  withContactInfo,   includeInactive} = {}) {...}

---------------------------------------------------------------------------------------------------------------------------------------


var Foo = {
	Foo: function(who) {
		this.me = who;
		return this;
	},
	identify: function() {
		return "I am " + this.me;
	}
};

var Bar = Object.create(Foo);

Bar.Bar = function(who) {
	// "constructors" (aka "initializers") are now in the `[[Prototype]]` chain,
	// so `this.Foo(..)` works easily w/o any problems of relative-polymorphism
	// or .call(this,..) awkwardness of the implicit "mixin" pattern
	this.Foo("Bar:" + who);
	return this;
};


------------------------------------------10 04 2020--------------------------------------------------------------------
Добавил временные файлы counters3 , counters 4
Заменил системы с классами на паттерн Делегирование Поведения часть 1.
Конечные Изменения в файле counters4

Надо менять проверку Статуса Движения в файле move ?
нет добавим :
_check_ForNullTarget_ForOwner_ForMovingStatus(t)

            if (!target.counter.getMovingStatus()) {
            console.log('u try  to select static counter')
            return true
        }
и проверим работу

    getReadyToMoveUnderSMCcommand() {


Далее - подключаем counter4 к client и создаем каунтеры новым способом

------------------------------------------18 04 2020--------------------------------------------------------------------
Поправил баг с командирскимим бонусами

Делаем кнопки остановки

Проверить -  стек -дабл тайм добавить новый каунтер

------------------------------------------24 04 2020--------------------------------------------------------------------

Сделал рабочие кнопки Ассалт Мув , Дабл Тайм и End Movement

------------------------------------------24 04 2020--------------------------------------------------------------------

Делаем дорожный бонус

MUST start on the road, END on the road, and only travel along road hex sides (i.e., literally follow the road).

Создаем стак . Если на дороге - даем бонус . В мув процессе если целевой гекс не дорога - обнуляем . По завершению ходов прибавляем дорожный бонус 

стак мф == 0 .
проверка на бонус 
есть ? добавили
новый клик

таргет Хекс != роад (старт определяется в момент создания tmf +=1)? 
    стартовый гекс дорога ?
        tmf -= 1
        проверяем не кончились ли мf ?
            да - tmf +=1 return

как хранить карту(типы гексов)

------------------------------------------01 05 2020--------------------------------------------------------------------

Сделали все бонусы при передвижении по дороге
Изменение бонусов при сходе с дороги

------------------------------------------02 05 2020--------------------------------------------------------------------

Реализация Defencive Fire
Кнопка DF . 
ПО кнопке - новый Сanvas Listener 

добавили взаимодействие с интерфейсом стека

------------------------------------------04 05 2020--------------------------------------------------------------------
Добавление сквада с орудием в группу
Новая сущность - группа(сквад + орудие) ?
Интерфейс - добавить Сквад в Огневую группу , добавить Орудие

---------------------------------------------------------------------------------------------------------------------

1) аттачим орудие к союзникам
2) на деф фазе если выбираем его  - разбиваем группу , пишем цель

в конце фащы огня всех приаттачиваем обратно

хотя можно реализовать преп файр

---------------------------------------------------------------------------------------------------------------------

При создании группы давать ей свойство = 'Weapon group'
ПРи создании Огневого стека проверять на 'Weapon group'.
Если да , то рисуем кнопки :
'Add Weapon To Fire Group'
'Add Squad To Fire Group'
'Add Both W and S'
По нажатию 

придется делать buildGroupUI , чтобы при повторном выборе группы , где уже выбран Сквад можно было бы добавить Орудие (и обр.)


------------------------------------------17 05 2020--------------------------------------------------------------------

Вынес кнопочные коллбеки в файл
Добавил кнопки добавления Орудия или Отряда в ПрепФайр Фазу
Поправил очистку UI в фазе движения
Тени под кнопками - box-shadow

Реализовал :
убрать кнопки управления группой при клике

addToFiringStack

Реализовать :

клик на группу - выбор орудия - клик на другой Каунт. - убираем UI - добавляем - клик на группу опять - UI c изменениями

firingStack {
    'hex_counter_Hash':{}
}

calculateCommanderBonus


надо выстроить их  в цепочку:
1) проверяем Лос у всех гексов
2) удаляем ЛОсовые гексы из массива
3) для каждого шекса находим ближайшие. Если таковых больше нет - создаем новую группу - файр процессинг
4) если есть - добавляем во временный массив

------------------------------------------26 05 2020--------------------------------------------------------------------

Реализовано:

кнопки добавления в группу
fire processing, fire stack
prepfire start,
box shadow



    getActualFirePower(fp,coweringCoefficient) {

        let array =  Object.keys(this.infantryFireTable)

        var closest = array.reduce((prev, curr) => {
            return (Math.abs(curr - fp) < Math.abs(prev - fp) ? curr : prev);
          });

        let index = array.indexOf(closest)

        return array[index+coweringCoefficient]
        //if ()
    }

в game


calculateWorstHindranceDRM

------------------------------------------29 05 2020--------------------------------------------------------------------

Поломка Пулемета
Сохранение РоФ 
воздействие выстрела на стрелков :
    статус
    группа 
    анимация
атака одного и того же гекса из одного гекса
// let effectOnFirer        ????
// this.useFireOnFirer

пулемет может образовывать стек только  со своим хозяином ?


каунтер  - свойство .groupElements - хранит все элементы , если counter.group
например , если есть пулемет.img
теперь, пулемет со статусом. вместо пулемет.img используем пулемет.group

вводим basicImg = загруженный img
вводим .img = basicImg

стреляет каунтер с пулеметом
уничтожаем группу каунтера
строим заново с измененным статусом ('first fire')
теперь в группе  - статус и пулемет.img
далее стреляет пулемет
строим группу пулемета 
меняем img на группу
иначе при движении пойдет только картинка пулемета без статуса

calculateGroupScheme()

В начале любой манипуляции с имаджем проверяем на наличие группы и вписываем как имадж


_isCounterNearStack

1) если группа  - разбиваем, стираем
    a) создаем новый текст бокс 


------------------------------------------04 06 2020--------------------------------------------------------------------

counter.groupScheme = {
    firingStatus : counter.firingStatusAsTextbox,   ??
    weapon : undefined,
    exhaustion : undefined,
}

this.calculateCoordsForFiringStatusTextbox(counter) {
    let l = counter.img.left
    let t = counter.img.top
    let w = counter.img.width
    return {
            left: l - w / 2 - 12,
            top: t + w / 2,
    }
}

this.drawCounterGroupOnScreen(counter) = {
    let counterImg = counter.img
    let arr = []

    for (let name of counter.groupScheme){
        if (counter.groupScheme[name] == 'firingStatus') {
            let coords =  this.calculateCoordsForFiringStatusTextbox(counter)
            let t = this.canvasObj.createPhaseTextBox
            t.set(coords)
            arr.push(t)
        }
    }

    let g = this.canvasObj.createGroup(...arr)

    this.canvasObj.drawGroup(g)
}

this.drawCounterGroupOnScreen(counter,coords) = {
    counter.img.set
}

------------------------------------------05 06 2020--------------------------------------------------------------------

changeColorOfBorder(counter, color) - вводим counter.initialImg , меняем его


Группа ставит свои коорлдинаты  == 5 и 5 , когда присоеденяется к группе . И возвращает прежние при отделении
                console.log(img)
                i.addWithUpdate(img)

                console.log(img)

                i.removeWithUpdate(img)
                console.log(img)

------------------------------------------05 06 2020--------------------------------------------------------------------

Заменил img на group.
Теперь для редактирования огневого статуса есть counter.text 
                          орудия - counter.group.weapon
Работает

------------------------------------------05 06 2020--------------------------------------------------------------------

Преп фаза
Каждый каунтер получает Статус

------------------------------------------11 06 2020--------------------------------------------------------------------

Реализовано =- влияние ведения огня на Отряд , Пулемет - 

Опять от проблем с группами спас волшебный .set (в flipCounterOnOtherSide) . Не обновлялась картинка пока не сработал set

------------------------------------------18 06 2020--------------------------------------------------------------------

Реализовал:

Работает проверка на пересечение Линии видимости и Линии преграды

------------------------------------------19 06 2020 ----------------------------------------------------------------------

Делаем огонь из нескольких гексов с отсутствующим Лос

------------------------------------------ 30 06 2020 ---------------------------------------------------------------------

Реализовано :
При обнаружении ведущего огонь гекса без ЛоС строится пара кнопок с возможностью выстрелить погруппно или погексово
При огне погруппно строятся новые отдельные  стаки и вызывается fireProcessing для каждого из них

Однако необходим эффект огня также и для остатков

Разделим fireProcessing на 

stack setHex_LoS_Hindrance
if(!this.isEveryFiringHexGotLoS(stack) && stack.getNumberOfHexes()>1)
    buildButton&&Stuff

fireProcessing :
вынесем эффект на стреляющего вверх
эффект на цель запускаем если !stack.noLoSforEveryCounter


    fireAsSeparateGroups(button, ops) {


        // rebuild all possible stacks
        // for each call fire processing

        // let hexesWithoutLoSArray = 
        let hexesWithoutLoSArray = ops.stack.getHexesWithoutLoSArray()
        let hexesWithLoSArray = ops.stack.getHexesWithLoSArray()
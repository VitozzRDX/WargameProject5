идея
InfantryMoveProcessing
VehicleMoveProcessing
===============================================================================================================================
идея

this.canvasObj.setOffMouseClickListener()

this.canvasObj.createPromiseAnimation(img, coords)
    .then(() => {
        this.setMouseClickListenerAccordingToCurrentPhase()
        callback()
    })

вынести в отдельную ф-ию 
animation(what,where,callback,param)

все анимации будут через нее , напр

this.canvasObj.setOffMouseClickListener()

this.canvasObj.createPromiseAnimation(img, coords)
    .then(() => {
        this.setMouseClickListenerAccordingToCurrentPhase()
        this.rearrangeCountersPositionInHex(previousHex)

        if (this._checkIfMovementPointsEnded(movingCounter)) {

            this.setMOVEDstatus_NullBorderColor_RemoveFromStack(movingCounter, img)
        }


        if (this.getMovingGroupArrayLength() == 0) {        //  && getMovingStackStatus() == 'filledWithBrokenStackRemnants'

            this.clearMovingGroupHash('uncreated')
            return console.log('all untis from MG have ended its move ')
        }
    })

===============================================================================================================================

поменять все _checkIf... на _is 
например

_checkIfHexIsInCoverArc = _isHexIsInCoverArc
_isAnEnemyInHex

===========================================================================================================================
        //-------------------- 17 03 2020 Phase Switching ---------------------------------
        this.ge467 = undefined
        this.ge468 = undefined
        this.ge91 = undefined

//-------------------- 17 03 2020 Phase Switching ---------------------------------
// this.interface.clickOn(`End ${this.firstPlayer}'s Phase`)
// this.interface.clickOn(`End ${this.secondPlayer}'s Rally`)
// //this.interface.clickOn(`End ${this.firstPlayer}'s Phase`)
// setTimeout(()=>{
//     this.interface.clickOn(`End ${this.firstPlayer}'s Phase`)
// },1000)


===========================================================================================================================
разделить _createAndDrawCounters :

        for (let i in parametersOnCreationHash) {

            let arrayOfCoords = parametersOnCreationHash[i]

            arrayOfCoords.forEach((obj) => {

                let c = this.createCounterObject(className, ops) //{ src: src, options: options, otherSideSrc: otherSideSrc }

                this.fillCounterTrayHash(c.ID, c)
            })
        }
затем

        CounterTray.forEach(
            this.drawCounter(c)

===========================================================================================================================

кажется я понял идею Композиции

Например Чтобы создать танк мы вызываем новую Арту внутри Танка и добавляем нужное поведение

===========================================================================================================================

let Breakable {
    breake(){
        set status 'broken'
    }

    remont()
}

===========================================================================================================================

_is_Click_NotInCoverArc_inOwnHex_onEnemy_EnterCostTooHigh - переделать - дать стеку ownHex , coverArc равный первому добавленному каунтеру, таблицу стоимости входа
Вопрос - что если у кого то МФ осталось меньше остальных ?
Вынесем 
_isCostToEnterHigherMFLeft

===========================================================================================================================

при выстреле - скуад - пачка параллельных трассеров . сквад единожды дрогается
командир - однократный трассеро
пулемет - трясется длинный трассер

========================================================================================================================================

при DFF - не надо выбирать цель . только стрелков . ЗАтем огонь по кнопке ? Плохо

==========================================================================================================================================

isLoSIncludingTargetHex - меряет лос включая последний (например для определения ТЕМ woods-road)

==========================================================================================================================================
calculateCounterFirePower - учитываем фазу и состояние каунтера здесь
==========================================================================================================================================

        // switch between different Phases 
        // PFPh , DFFPh
        // in case DFFPh :
        // if stack.firingStatus  == 'First Fire' && targetHex not closest between possible
        // return
==========================================================================================================================================

hex хранит инфу откуда стреляли

======================================================================================================================================

при пересечении ЛоС типа Холм - проверяем разницу в высотах . Если есть то нет ЛоС . При этом сам гекс не входит в ЛоС

===================================================================================================================================

круглая кнопка с радиальным градиентом - реализовал

=================================================================================================================================

http://css.yoksel.ru/3d-cube/